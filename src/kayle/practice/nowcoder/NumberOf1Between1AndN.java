package kayle.practice.nowcoder;
/*
 * 题目描述:
 * 求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？
 * 为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,
 * 但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,
 * 可以很快的求出任意非负整数区间中1出现的次数。
 * 题意就是想要求1-n这个区间的所有数字总共出现了多少次1
 * 
 * 解题思路:
 * 我直接用了最傻的办法,一位一位去计算,但是这在n很大的时候会导致时间很长
 * 
 * 别人有一种比较巧妙的办法 a = n/m 作为高位数字 b= n%m 作为低位数字
 * 依次从个十百千万 把每个位置的1都计算出来
 * 在计算的时候可以分成3总情况,当前计算的位数上的数字>=2 或 =1 或 =0
 * 1.当>=2的时候,说明肯定包含了2以下所有的数,比如说31456这个数字,在计算百位数有多少1的时候
 *   分成了314和56, 因为4>=2,所以当4这个位置为1的时候,前面的千位万位到31总共有32总取法(00~31)
 *   后面的各位和十位都有100种(00-99),所以这种情况总共有 (a + 1)/10 * m种
 * 2.当=1的时候 前面千位万位只能有31种(00-30),在取31的时候,后面的个位十位的种数要根据实际计算
 *   比如说现在是56,那么只有57种取法(00-56) 也就是 b+1种 有 a/10 *m +(b+1)
 * 3.当=0的时候,那么百位为1的时候 千万位就只能是31种(00-30)
 * 以下是实现的代码,+8是因为1,2,3这3种情况可以整合起来,当n/m这位数字>=2的时候 再+8刚好能凑>=10进位
 * 就变成了(a+1)/10 *m
 * 否则就还是a/10 *m, 后面一半加不加b+1 取决于百位数等不等于1,只有等于1的时候后面才要加上b+1
 * public int countDigitOne(int n) {
    int ones = 0;
    for (long m = 1; m <= n; m *= 10)
        ones += (n/m + 8) / 10 * m + (n/m % 10 == 1 ? n%m + 1 : 0);
    return ones;
	}
 * */
public class NumberOf1Between1AndN {
    public int NumberOf1Between1AndN_Solution(int n) {
    	int count = 0;
    	for (int i = 1; i <= n; i++) {
    		int j = i;
			while(j >= 10) {
				if(j % 10 == 1) { 
					count++;
				}
				j = j / 10;
			}
			if(j == 1) {
				count++;
			}
		}
    	return count;
    }
}

